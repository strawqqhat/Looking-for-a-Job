## leetcode hot-100

| #    | 题名 | 题解                                                         | 通过率 | 难度  | 出现频率 |      |
| ---- | ---- | ------------------------------------------------------------ | ------ | ----- | :------: | ---- |
|      | 1    | [两数之和](https://leetcode-cn.com/problems/two-sum)         |        | 46.5% |   简单   |      |
|      | 2    | [两数相加](https://leetcode-cn.com/problems/add-two-numbers) |        | 35.5% |   中等   |      |
|      | 3    | [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters) |        | 31.1% |   中等   |      |
|      | 4    | [寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays) |        | 35.9% |   困难   |      |
|      | 5    | [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring) |        | 26.9% |   中等   |      |
|      | 10   | [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching) |        | 24.6% |   困难   |      |
|      | 11   | [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water) |        | 57.3% |   中等   |      |
|      | 15   | [三数之和](https://leetcode-cn.com/problems/3sum)            |        | 23.8% |   中等   |      |
|      | 17   | [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number) |        | 50.8% |   中等   |      |
|      | 19   | [删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list) |        | 35.3% |   中等   |      |
|      | 20   | [有效的括号](https://leetcode-cn.com/problems/valid-parentheses) |        | 39.4% |   简单   |      |
|      | 21   | [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists) |        | 56.9% |   简单   |      |
|      | 22   | [括号生成](https://leetcode-cn.com/problems/generate-parentheses) |        | 71.6% |   中等   |      |
|      | 23   | [合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists) |        | 47.4% |   困难   |      |
|      | 31   | [下一个排列](https://leetcode-cn.com/problems/next-permutation) |        | 31.8% |   中等   |      |
|      | 32   | [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses) |        | 28.1% |   困难   |      |
|      | 33   | [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array) |        | 36.1% |   中等   |      |
|      | 34   | [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array) |        | 37.6% |   中等   |      |
|      | 39   | [组合总和](https://leetcode-cn.com/problems/combination-sum) |        | 66.6% |   中等   |      |
|      | 42   | [接雨水](https://leetcode-cn.com/problems/trapping-rain-water) |        | 46.1% |   困难   |      |
|      | 46   | [全排列](https://leetcode-cn.com/problems/permutations)      |        | 71.4% |   中等   |      |
|      | 48   | [旋转图像](https://leetcode-cn.com/problems/rotate-image)    |        | 63.8% |   中等   |      |
|      | 49   | [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams) |        | 58.3% |   中等   |      |
|      | 53   | [最大子序和](https://leetcode-cn.com/problems/maximum-subarray) |        | 47.2% |   简单   |      |
|      | 55   | [跳跃游戏](https://leetcode-cn.com/problems/jump-game)       |        | 36.0% |   中等   |      |
|      | 56   | [合并区间](https://leetcode-cn.com/problems/merge-intervals) |        | 38.1% |   中等   |      |
|      | 62   | [不同路径](https://leetcode-cn.com/problems/unique-paths)    |        | 55.8% |   中等   |      |
|      | 64   | [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum) |        | 62.3% |   中等   |      |
|      | 70   | [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)   |        | 46.6% |   简单   |      |
|      | 72   | [编辑距离](https://leetcode-cn.com/problems/edit-distance)   |        | 53.9% |   困难   |      |
|      | 75   | [颜色分类](https://leetcode-cn.com/problems/sort-colors)     |        | 52.7% |   中等   |      |
|      | 76   | [最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring) |        | 36.1% |   困难   |      |
|      | 78   | [子集](https://leetcode-cn.com/problems/subsets)             |        | 74.7% |   中等   |      |
|      | 79   | [单词搜索](https://leetcode-cn.com/problems/word-search)     |        | 38.8% |   中等   |      |
|      | 84   | [柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram) |        | 37.3% |   困难   |      |
|      | 85   | [最大矩形](https://leetcode-cn.com/problems/maximal-rectangle) |        | 42.9% |   困难   |      |
|      | 94   | [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal) |        | 67.7% |   中等   |      |
|      | 96   | [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees) |        | 62.0% |   中等   |      |
|      | 98   | [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree) |        | 27.4% |   中等   |      |
|      | 101  | [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree) |        | 48.2% |   简单   |      |
|      | 102  | [二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) |        | 58.4% |   中等   |      |
|      | 104  | [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree) |        | 70.7% |   简单   |      |
|      | 105  | [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal) |        | 61.0% |   中等   |      |
|      | 114  | [二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list) |        | 64.5% |   中等   |      |
|      | 121  | [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock) |        | 50.6% |   简单   |      |
|      | 124  | [二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum) |        | 37.5% |   困难   |      |
|      | 128  | [最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence) |        | 46.6% |   困难   |      |
|      | 136  | [只出现一次的数字](https://leetcode-cn.com/problems/single-number) |        | 63.1% |   简单   |      |
|      | 139  | [单词拆分](https://leetcode-cn.com/problems/word-break)      |        | 42.7% |   中等   |      |
|      | 141  | [环形链表](https://leetcode-cn.com/problems/linked-list-cycle) |        | 42.6% |   简单   |      |

#### 1. [两数之和](https://leetcode-cn.com/problems/two-sum)  

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        int[] res = new int[2];
        for(int i=0; i<nums.length; i++){
            if(map.containsKey(target-nums[i])){
                res[0] = map.get(target-nums[i]);
                res[1] = i;
            }
            map.put(nums[i], i);
        }
        return res;
    }
}
```



#### 2. [两数相加](https://leetcode-cn.com/problems/add-two-numbers)  

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode res = new ListNode(0);
        ListNode p = l1, q = l2, cur = res;
        int carry = 0;
        while(p != null || q != null){
            int x = p != null? p.val : 0;
            int y = q != null? q.val : 0;
            int sum = x + y + carry;
            carry = sum/10;
            cur.next = new ListNode(sum % 10);
            cur = cur.next;
            if(p != null) p = p.next;
            if(q != null) q = q.next;
        }
        if(carry > 0){
            cur.next = new ListNode(carry);
        }
        return res.next;
    }
}
```



#### 3. [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters) 

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int res = 0;
        int n = s.length();
        int rk = -1;
        Set<Character> set = new HashSet<>();
        for(int i=0; i<n; i++){
            if(i != 0){
                set.remove(s.charAt(i-1));
            }
            while(rk+1<n&&!set.contains(s.charAt(rk+1))){
                set.add(s.charAt(rk+1));
                rk++;
            }
            res = Integer.max(res, rk-i+1);
        }
        return res;
    }
}
```



#### 5. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        String ans = "";
        for(int l=0; l<n; l++){
            for(int i=0; i+l<n; i++){
                int j = i+l;
                if(l == 0){
                    dp[i][j] = true;
                }else if(l == 1){
                    dp[i][j] = (s.charAt(i) == s.charAt(j));
                }else{
                    dp[i][j] = (s.charAt(i) == s.charAt(j))&&dp[i+1][j-1];
                }
                if(dp[i][j]&&l+1>ans.length()){
                    ans = s.substring(i,j+1);
                }
            }
        }
        return ans;
    }
}
```



#### 11. [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```java
class Solution {
    public int maxArea(int[] height) {
        int ans = 0;
        int n = height.length;
        int p = 0;
        int q = n-1;
        while(p <= q){
            if((q-p)*Math.min(height[p], height[q])>ans){
                ans = (q-p)*Math.min(height[p], height[q]);
            }
            if(height[p]>=height[q]){
                q--;
            }else{
                p++;
            }
        }
        return ans;
    }
}
```



#### 15. [三数之和](https://leetcode-cn.com/problems/3sum/)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        int n = nums.length;
        Arrays.sort(nums);
        for(int first=0; first<n; first++){
            if(first>0&&nums[first]==nums[first-1]){
                continue;
            }
            int third = n-1;
            int target = -nums[first];
            for(int second=first+1; second<n; second++){
                if(second>first+1&&nums[second]==nums[second-1]){
                    continue;
                }
                while(second<third&&nums[second]+nums[third]>target){
                    third--;
                }
                if(second == third){
                    break;
                }
                if(nums[second]+nums[third]==target){
                    List<Integer> t = new ArrayList<>();
                    t.add(nums[first]);
                    t.add(nums[second]);
                    t.add(nums[third]);
                    ans.add(t);
                }
            }
        }
        return ans;
    }
}
```



#### 17. [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> ans = new ArrayList<>();
        if(digits.length() == 0){
            return ans;
        }
        Map<Character, String> phoneMap = new HashMap<>();
        phoneMap.put('2', "abc");
        phoneMap.put('3', "def");
        phoneMap.put('4', "ghi");
        phoneMap.put('5', "jkl");
        phoneMap.put('6', "mno");
        phoneMap.put('7', "pqrs");
        phoneMap.put('8', "tuv");
        phoneMap.put('9', "wxyz");
        backtrack(ans, phoneMap, digits, 0, new StringBuffer());
        return ans;
    }
    public void backtrack(List<String> ans, Map<Character, String> phoneMap, String digits, int index, StringBuffer sb){
        if(index == digits.length()){
            ans.add(sb.toString());
        }else{
            char digit = digits.charAt(index);
            String letters = phoneMap.get(digit);
            int lettersCount = letters.length();
            for(int i=0; i<lettersCount; i++){
                sb.append(letters.charAt(i));
                backtrack(ans, phoneMap, digits, index+1, sb);
                sb.deleteCharAt(index);
            }
        }
    }
}
```



#### 19. [删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode ans = new ListNode(0);
        ans.next = head;
        ListNode first = head;
        int len = 0;
        while(first != null){
            len++;
            first = first.next;
        }
        len -= n;
        first = ans;
        while(len > 0){
            len--;
            first = first.next;
        }
        first.next = first.next.next;
        return ans.next;
    }
}
```



#### 20. [有效的括号](https://leetcode-cn.com/problems/valid-parentheses)  

```java
class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        if(n%2 == 1){
            return false;
        }
        Map<Character, Character> map = new HashMap<>();
        map.put(')','(');
        map.put(']','[');
        map.put('}','{');
        Stack<Character> stack = new Stack<>();
        for(int i=0; i<n; i++){
            char c = s.charAt(i);
            if(map.containsKey(c)){
                if(stack.empty()||stack.peek()!=map.get(c)){
                    return false;
                }
                stack.pop();
            }else{
                stack.push(c);
            }
        }
        return stack.empty();
    }
}
```



#### 21. [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)  

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode p = l1;
        ListNode q = l2;
        ListNode cur = new ListNode(0);
        ListNode res = cur;
        while(p != null && q != null){
            if(p.val <= q.val){
                cur.next = new ListNode(p.val);
                p = p.next;
            }else{
                cur.next = new ListNode(q.val);
                q = q.next;
            }
            cur = cur.next;
        }
        if(p != null){
            cur.next = p;
        }
        if(q != null){
            cur.next = q;
        }
        return res.next;

    }
}
```



#### 22. [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<>();
        if(n == 0){
            return ans;
        }
        dfs("", n, n, ans);
        return ans;
    }
    public void dfs(String curStr, int left, int right, List<String> ans){
        if(left == 0 && right == 0){
            ans.add(curStr);
            return;
        }
        if(left > 0){
            dfs(curStr+"(", left-1, right, ans);
        }
        if(right > 0&&left < right){
            dfs(curStr+")", left, right-1, ans);
        }
    }
}
```



#### 31. [下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while(i >= 0 && nums[i+1] <= nums[i]){
            i--;
        }
        if(i >= 0){
            int j = nums.length - 1;
            while(j >= 0 && nums[j] <= nums[i]){
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i+1);
    }
    public void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    public void reverse(int[] nums, int start){
        int i = start;
        int j = nums.length - 1;
        while(i < j){
            swap(nums, i, j);
            i++;
            j--;
        }
    }
}
```



#### 33. [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if(n == 0){
            return -1;
        }
        if(n == 1){
            return nums[0]==target?0 : -1;
        }
        int l = 0, r = n-1;
        while(l <= r){
            int mid = l + (r-l)/2;
            if(nums[mid] == target){
                return mid;
            }
            if(nums[0] <= nums[mid]){
                if(nums[0]<=target&&target<nums[mid]){
                    r = mid-1;
                }else{
                    l = mid+1;
                }
            }else{
                if(nums[mid]<target&&target<=nums[n-1]){
                    l = mid+1;
                }else{
                    r = mid-1;
                }
            }
        }
        return -1;
    }
}
```



#### 34. [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] ans = {-1, -1};
        ans[0] = left_bound(nums, target);
        ans[1] = right_bound(nums, target);
        return ans;
    }
    public int left_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0;
        int right = nums.length; // 注意
        
        while (left < right) { // 注意
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid; // 注意
            }
        }
        if(left == nums.length) return -1;
        return nums[left]==target?left:-1;
    }

    public int right_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0, right = nums.length;
        
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                left = mid + 1; // 注意
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        if(left == 0) return -1;
        return nums[left-1]==target?left-1:-1;
    }
}
```



#### 39. [组合总和](https://leetcode-cn.com/problems/combination-sum/)

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> tmp = new ArrayList<>();
        Arrays.sort(candidates);
        dfs(res, tmp, candidates, target, 0);
        return res;
    }

    public void dfs(List<List<Integer>> res, List<Integer> tmp, int[] candidates, int target, int num){
        if(target == 0){
            res.add(tmp);
        }
        if(target < candidates[0]){
            return;
        }
        for(int i=num; i<candidates.length&&candidates[i]<=target; i++){
            List<Integer> list = new ArrayList<>(tmp);
            list.add(candidates[i]);
            dfs(res, list, candidates, target-candidates[i], i);
        }
    }
}
```



#### 46. [全排列](https://leetcode-cn.com/problems/permutations/)

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> list = new ArrayList<>();
        dfs(res, list, nums);
        return res;
    }

    public void dfs(List<List<Integer>> res, List<Integer> list, int[] nums){
        if(list.size() == nums.length){
            res.add(new ArrayList<Integer>(list));
        }
        for(int num : nums){
            if(!list.contains(num)){
                list.add(num);
                dfs(res, list, nums);
                list.remove(list.size()-1);
            }
        }
    }
}
```



#### 48. [旋转图像](https://leetcode-cn.com/problems/rotate-image/)

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for(int i=0; i<n; i++){
            for(int j=i; j<n; j++){
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] =  tmp;
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<n/2; j++){
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[i][n-j-1];
                matrix[i][n-j-1] = tmp;
            }
        }
    }
}
```



#### 49. [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        if(strs.length == 0){
            return res;
        }
        Map<String, List> ans = new HashMap<>();
        for(String s : strs){
            char[] ca = s.toCharArray();
            Arrays.sort(ca);
            String key = String.valueOf(ca);
            if(!ans.containsKey(key)){
                ans.put(key, new ArrayList());
            }
            ans.get(key).add(s);
        }
        return new ArrayList(ans.values());
    }
}
```



#### 53. [最大子序和](https://leetcode-cn.com/problems/maximum-subarray)  

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        int n = nums.length;
        int sum = 0;
        for(int i=0; i<n; i++){
            if(sum > 0){
                sum += nums[i];
            }else{
                sum = nums[i];
            }
            res = Math.max(sum, res);
        }
        return res;
    }
}
```



#### 55. [跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

```java
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int ans = 0;
        for(int i=0; i<n; i++){
            if(i <= ans){
                ans = Math.max(ans, nums[i]+i);
                if(ans >= n-1){
                    return true;
                }
            }
        }
        return false;
    }
}
```



#### 56. [合并区间](https://leetcode-cn.com/problems/merge-intervals/)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;
        if(n == 0){
            return new int[0][2];
        }
        Arrays.sort(intervals, new Comparator<int[]>(){
            public int compare(int[] interval1, int[] interval2){
                return interval1[0] - interval2[0];
            }
        });
        List<int[]> merge = new ArrayList<>();
        for(int i=0; i<n; i++){
            int L = intervals[i][0], R = intervals[i][1];
            if(merge.size() == 0 || L > merge.get(merge.size()-1)[1]){
                merge.add(new int[]{L, R});
            }else{
                merge.get(merge.size()-1)[1] = Math.max(merge.get(merge.size()-1)[1], R);
            }
        }
        return merge.toArray(new int[merge.size()][]);
    }
}
```

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;
        Arrays.sort(intervals, (a, b)->a[0]-b[0]);
        List<int[]> list = new ArrayList<>();
        for(int i=0; i<n;){
            int t = intervals[i][1];
            int j = i + 1;
            while(j < n && intervals[j][0] <= t){
                t = Math.max(t, intervals[j][1]);
                j++;
            }
            list.add(new int[]{intervals[i][0], t});
            i = j;
        }
        int size = list.size();
        int[][] res = new int[size][2];
        for(int i=0; i<size; i++){
            res[i] = list.get(i);
        }
        return res;
    }
}
```



#### 62. [不同路径](https://leetcode-cn.com/problems/unique-paths/)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int dp[][] = new int[m][n];
        for(int i=0; i<n; i++){
            dp[0][i] = 1;
        }
        for(int i=0; i<m; i++){
            dp[i][0] = 1;
        }
        for(int i=1; i<m; i++){
            for(int j=1; j<n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```



#### 64. [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rows = grid.length, columns = grid[0].length;
        int[][] dp = new int[rows][columns];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < columns; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < columns; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[rows - 1][columns - 1];
    }
}

```



#### 70. [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)  

```java
class Solution {
    public int climbStairs(int n) {
        int p = 0, q = 0;
        int res = 1;
        for(int i=1; i<=n; i++){
            p = q;
            q = res;
            res = p + q;
        }
        return res;
    }
}
```



#### 75. [颜色分类](https://leetcode-cn.com/problems/sort-colors/)

```java
class Solution {
    public void sortColors(int[] nums) {
        int p0 = 0, p2 = nums.length-1, curr = 0;
        while(curr <= p2){
            if(nums[curr] == 0){
                int tmp = nums[curr];
                nums[curr] = nums[p0];
                nums[p0] = tmp;
                curr++;
                p0++;
            }else if(nums[curr] == 2){
                int tmp = nums[curr];
                nums[curr] = nums[p2];
                nums[p2] = tmp;
                p2--;
            }else{
                curr++;
            }
        }
    }
}
```



#### 78. [子集](https://leetcode-cn.com/problems/subsets/)

```java
class Solution {
    List<Integer> t = new ArrayList<>();
    List<List<Integer>> res = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsets(int[] nums) {
        dfs(0, nums);
        return res;
    }

    void dfs(int cur, int nums[]){
        if(cur == nums.length){
            res.add(new ArrayList<Integer>(t));
            return;
        }
        t.add(nums[cur]);
        dfs(cur+1, nums);
        t.remove(t.size()-1);
        dfs(cur+1, nums);
    }
}
```



#### 79. [单词搜索](https://leetcode-cn.com/problems/word-search/)

```java
class Solution {
    private boolean[][] marked;
    private int[][] direction = {{-1,0}, {0,-1},{0,1}, {1,0}};
    private int m;
    private int n;
    private String word;
    private char[][] board;

    public boolean exist(char[][] board, String word) {
        m = board.length;
        if(m == 0){
            return false;
        }
        n = board[0].length;
        marked = new boolean[m][n];
        this.word = word;
        this.board = board;
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(dfs(i, j, 0)){
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(int i, int j, int start){
        if(start == word.length()-1){
            return board[i][j] == word.charAt(start);
        }
        if(board[i][j] == word.charAt(start)){
            marked[i][j] = true;
            for(int k=0; k<4; k++){
                int newX = i + direction[k][0];
                int newY = j + direction[k][1];
                if(inArea(newX, newY) && !marked[newX][newY]){
                    if(dfs(newX, newY, start+1)){
                        return true;
                    }
            }
            }
            marked[i][j] = false;
        }
        return false;
    }
    private boolean inArea(int x, int y){
        return x>=0 && x<m && y>=0 && y<n;
    }
}
```



#### 94. [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List<Integer> res){
        if(root == null){
            return;
        }
        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
}
```



#### 96. [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

```java
class Solution {
    public int numTrees(int n) {
        int[] G = new int[n+1];
        G[0] = 1;
        G[1] = 1;
        for(int i=2; i<=n; i++){
            for(int j=1; j<=i; j++){
                G[i] += G[j-1]*G[i-j];
            }
        }
        return G[n];
    }
}
```



#### 98. [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }

    public boolean helper(TreeNode node, Integer lower, Integer higher){
        if(node == null){
            return true;
        }
        int val = node.val;
        if(lower != null && val <= lower){
            return false;
        }
        if(higher != null && val >= higher){
            return false;
        }
        if(!helper(node.left, lower, val)){
            return false;
        }
        if(!helper(node.right, val, higher)){
            return false;
        }
        return true;
    }
}
```



#### 101. [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree)  

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }
    public boolean check(TreeNode left, TreeNode right){
        if(left == null && right == null){
            return true;
        }
        if(left == null || right == null){
            return false;
        }
        return left.val==right.val&&check(left.right, right.left)&&check(left.left, right.right);
    }
}
```



#### 102. [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null){
            return res;
        }
        List<TreeNode> nodes = new ArrayList<>();
        nodes.add(root);
        while(!nodes.isEmpty()){
            int size = nodes.size();
            List<Integer> list = new ArrayList<>();
            for(int i=0; i<size; i++){
                TreeNode remove = nodes.remove(0);
                list.add(remove.val);
                if(remove.left != null){
                    nodes.add(remove.left);
                }
                if(remove.right != null){
                    nodes.add(remove.right);
                }
            }
            res.add(list);
        }
        return res;
    }
}
```



#### 104. [ 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree)  

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }else{
            int leftHight = maxDepth(root.left);
            int rightHight = maxDepth(root.right);
            return Math.max(leftHight, rightHight) + 1;
        }
    }
}
```



#### 105. [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTreeHelper(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }

    private TreeNode buildTreeHelper(int[] preorder, int p_start, int p_end, int[] inorder, int i_start, int i_end){
        if(p_start == p_end){
            return null;
        }
        int root_val = preorder[p_start];
        TreeNode root = new TreeNode(root_val);
        int i_root_index = 0;
        for(int i=i_start; i<i_end; i++){
            if(root_val == inorder[i]){
                i_root_index = i;
                break;
            }
        }
        int leftNum = i_root_index - i_start;
        root.left = buildTreeHelper(preorder, p_start+1, p_start+leftNum+1, inorder, i_start, i_root_index);
        root.right = buildTreeHelper(preorder,  p_start+leftNum+1, p_end, inorder, i_root_index+1, i_end);
        return root;
    }
}
```



#### 114. [二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        List<TreeNode> list = new ArrayList<>();
        preorderTraversal(root, list);
        int size = list.size();
        for(int i=1; i<size; i++){
            TreeNode prev = list.get(i-1);
            TreeNode curr = list.get(i);
            prev.left = null;
            prev.right = curr;
        }
    }

    public void preorderTraversal(TreeNode root, List<TreeNode> list){
        if(root != null){
            list.add(root);
            preorderTraversal(root.left, list);
            preorderTraversal(root.right, list);
        }
        
    }
}
```



#### 121. [ 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        if(prices == null || prices.length == 0){
            return 0;
        }
        int minPrice = prices[0];
        int n = prices.length;
        for(int i=1; i<n; i++){
            res = Math.max(res, prices[i]-minPrice);
            if(minPrice > prices[i]){
                minPrice = prices[i];
            }
        }
        return res;
    }
}
```



#### 136. [只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for(int i=0; i<nums.length; i++){
            res = res^nums[i];
        }
        return res;
    }
}
```



#### 139. [单词拆分](https://leetcode-cn.com/problems/word-break/)

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet(wordDict);
        boolean[] dp = new boolean[s.length()+1];
        dp[0] = true;
        for(int i=1; i<=s.length(); i++){
            for(int j=0; j<i; j++){
                if(dp[j]&&wordDictSet.contains(s.substring(j, i))){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```



#### 141. [环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null){
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while(slow != fast){
            if(fast == null || fast.next == null){
                return false;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        return true;
    }
}
```

